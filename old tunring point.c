 #pragma config(Sensor, in5,    ,               sensorPotentiometer)
#pragma config(Sensor, dgtl1,  lift,           sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  backleft,       sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  backright,      sensorQuadEncoder)
#pragma config(Motor,  port1,           Frontright,    tmotorVex393HighSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           frontleft,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           backright,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           liftright,     tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           liftleft,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           shooter,       tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           intake,        tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           L,             tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           backleft,      tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port10,           ,             tmotorVex393HighSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c" //Main competition background code...do not modify!

/////////////////////////////////////////////////////////////////////////////////////////
//
// Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
bStopTasksBetweenModes = true;
wait1Msec(2000);  //Two second Delay
  SensorValue[dgtl1] = 0;  //Clear the right encoder value
  SensorValue[dgtl3] = 0;
   SensorValue[dgtl5] = 0;//Clear the left encoder value

  //While the encoders have spun less than 3 rotations...
  //while(SensorValue[dgtl1] < 1080)
  //{
    //Move Forward
    //motor[port8] = 63;
  //}


  //Stop for half a second
  //motor[port8] = 0;
  //wait1Msec(500);
// All activities that occur befo re the competition starts
// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
// Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
// .....................................................................................
// Insert user code here.
// .....................................................................................

// port 1,2,9 go negative to go forward.
//port 3 is posotive to go forward

motor(port5)=127;//shoot at high right flag
wait1Msec(500);
motor(port5)=0;

while(SensorValue[dgtl1] < 1710)
  {

motor(port2)=-127;
motor(port3)=127;//left
motor(port1)=-127;
motor(port9)=-127;//drive forward toward low right flag		//right
  }


  //Stop for half a second
motor(port2)=0;
motor(port3)=0;//left
motor(port1)=0;
motor(port9)=0;//stop		//right
  wait1Msec(500);

  SensorValue[dgtl1] = 0;//clear encoder

while(SensorValue[dgtl1] <  360)
  {

motor(port2)=-127;
motor(port3)=127;//turn 135 degrees where shooter faces top right base		//left
  }


  //Stop for half a second
motor(port2)=0;
motor(port3)=0;//stop		//right
  wait1Msec(500);

   SensorValue[dgtl1] = 0;//clear encoder

while(SensorValue[dgtl1] < 1260)
  {

motor(port2)=-127;
motor(port3)=127;//left
motor(port1)=-127;
motor(port9)=-127; //drive forward toward top right base		//right
  }


  //Stop for half a second
motor(port2)=0;
motor(port3)=0;//left
motor(port1)=0;
motor(port9)=0;//stop		//right
  wait1Msec(500);

  SensorValue[dgtl1] = 0;//clear encoder


motor(port7)=127;//pick up ball
  wait1Msec(500);
motor(port7)=0;	//stop


while(SensorValue[dgtl1] < 180)
  {
  motor(port2)=127;
motor(port3)=-127;//left
motor(port1)=127;
motor(port9)=127;//go backward away from top right base  //right

  }
  //Stop for half a second
motor(port2)=0;
motor(port3)=0;//left
motor(port1)=0;
motor(port9)=0;//stop		//right
  wait1Msec(500);

SensorValue[dgtl1] = 0;//clear encoder

while(SensorValue[dgtl1] < 180)
  {
motor(port2)=127;
motor(port3)=127;//left
motor(port1)=-127;
motor(port9)=127;//turn 180 where L top right facing base		//right

  }
  //Stop for half a second
motor(port2)=0;
motor(port3)=0;//left
motor(port1)=0;
motor(port9)=0;//stop		//right
  wait1Msec(500);


SensorValue[dgtl1] = 0;//clear encoder

while(SensorValue[dgtl1] < 180)
  {

motor(port2)=-127;
motor(port3)=127;//left
motor(port1)=-127;
motor(port9)=-127; //drive toward toward top right base		//right
  }


  //Stop for half a second
motor(port2)=0;
motor(port3)=0;//left
motor(port1)=0;
motor(port9)=0;//stop		//right
  wait1Msec(500);

while(SensorValue[dgtl3] < 90)
  {

motor(port8)=127;//flip top right base
  }


  //Stop for half a second
motor(port8)=0;//stop
  wait1Msec(500);



  SensorValue[dgtl1] = 0;//clear encoder

  while(SensorValue[dgtl1] < 180)
  {

motor(port2)=127;
motor(port3)=127;//left
motor(port1)=-127;
motor(port9)=127;//turn 90 towards middle pole		//right
  }


  //Stop for half a second
motor(port2)=0;
motor(port3)=0;//left
motor(port1)=0;
motor(port9)=0;//stop		//right
  wait1Msec(500);



motor(port5)=127;//shoot at high middle flag
wait1Msec(500);
motor(port5)=0;

  SensorValue[dgtl1] = 0;//clear encoder

  while(SensorValue[dgtl1] < 1620)
  {
motor(port3)=127;
motor(port2)=-127;//left
motor(port9)=-127;
motor(port1)=-127;// drive foward toward low middle flag		//right
  }


  //Stop for half a second
motor(port2)=0;
motor(port3)=0;//left
motor(port1)=0;
motor(port9)=0;//stop		//right
  wait1Msec(500);

  while(SensorValue[dgtl1] < 180)
  {
motor(port3)=127;
motor(port2)=-127;//left
motor(port9)=-127;
motor(port1)=-127;// turn 45 degrees in order to straighten out the robot		//right
  }


  //Stop for half a second
motor(port2)=0;
motor(port3)=0;//left
motor(port1)=0;
motor(port9)=0;//stop		//right
  wait1Msec(500);




}

/////////////////////////////////////////////////////////////////////////////////////////
//
// User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()

// User control code here, inside the loop

{while (true)
{
// This is the main execution loop for the user control program. Each time through the loop
// your program should update motor + servo values based on feedback from the joysticks.

// .....................................................................................
// Insert user code here. This is where you use the joystick values to update your motors, etc.
// .....................................................................................
//*!!Code automatically generated by 'ROBOTC' configuration wizard           !!*///*
	motor(port1)= -vexRT[Ch2]; // port 1 is the right driver,front wheels
		motor(port3)= vexRT[Ch2];// port 10 is the left driver,front wheels
		motor(port9)= -vexRT[Ch3]; // port 1 is the leftdriver
		motor(port2)= vexRT[Ch3];// port 10 is the right driver

	if(vexRT[Btn8U] == 1) // if button 6u is pressed lift goes up
	{
		motor(port5)= -127;
		motor(port4)= 127;	//......raise the arm
	}
	else if(vexRT[Btn8D] ==1) // if button 6d is pressed lift goes down
	{
		motor(port5)= 127;
		motor(port4)= -127; // ... lower the arm
	}
	else // if nothing is pushed...
	{
		motor(port5)= 0;//im not writing any code im just extremely depressed
		motor(port4)= 0; // ...stop the arm
	}
	if (vexRT[Btn6D] ==1) //if button 8r is pressed elevator goes up
	{
		motor(port6) = -127;// .. raise the elevator
	}
	else // if nothing is pushed...
	{
		motor(port6) = 0;  //... elevator stops
	}
		if(vexRT[Btn5D] == 1) // if button 5u is close claw
	{
		motor(port7)= 127;
	}

else	if (vexRT[Btn5U] ==1) //if button 8r is pressed elevator goes up
	{
		motor(port7) = -127;// .. raise the elevator
	}

	else // if nothing is pushed...
	{
		motor(port7)= 0; // nothn happens
}
	if(vexRT[Btn7D] == 1) // if button 5u is close claw
	{
		motor(port8)= 127;

	}
	else if(vexRT[Btn7U] ==1) // if button 5d is pressed open claw
	{
		motor(port8)= -127;

	}
	else // if nothing is pushed...
	{
		motor(port8)= 0; // nothn happens
}
}
}
